<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <title>Subtítols</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 4em;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    #fileInputContainer {
      position: absolute;
      top: 1em;
      left: 1em;
      z-index: 10;
      font-size: 0.5em;
    }

    #current {
      position: absolute;
      width: 100%;
      text-align: center;
      padding: 0.5em;
      white-space: pre-line;
    }

    #next {
      position: absolute;
      width: 100%;
      text-align: center;
      padding: 0.5em;
      white-space: pre-line;
      font-size: 0.5em;
    }

    .align-top #current { top: 1em; }
    .align-center #current { top: 50%; transform: translateY(-50%); }
    .align-bottom #current { bottom: 1em; }

    .next-at-top #next { top: 0.5em; }
    .next-at-bottom #next { bottom: 0.5em; }

    .hide-next #next { display: none; }
  </style>
</head>
<body class="align-top next-at-bottom">
  <div id="fileInputContainer">
    <label for="fileInput">Carrega un fitxer de subtítols:</label>
    <input type="file" id="fileInput" accept=".txt">
  </div>

  <div id="current"></div>
  <div id="next"></div>

  <script>
    const currentDiv = document.getElementById('current');
    const nextDiv = document.getElementById('next');
    const fileInput = document.getElementById('fileInput');
    const fileInputContainer = document.getElementById('fileInputContainer');

    let subtitles = [];
    let accessPoints = [];
    let currentIndex = 0;
    let fontSize = 4;
    const fontStep = 0.2;
    let alignment = 'top';

    // Gestió de grisos: 20 nivells entre blanc (0) i negre (19)
    let grayLevel = 14; // corresponent a #2e2e2e aprox.
    const maxGray = 19;
    const minGray = 0;

    function setNextGray(level) {
      grayLevel = Math.min(maxGray, Math.max(minGray, level));
      const value = Math.round(255 - (grayLevel * (255 / maxGray)));
      const hex = value.toString(16).padStart(2, '0');
      nextDiv.style.color = `#${hex}${hex}${hex}`;
    }

    function updateFontSize() {
      document.body.style.fontSize = fontSize + 'em';
    }

    function updateAlignment(alignmentClass) {
      document.body.classList.remove(
        'align-top', 'align-center', 'align-bottom',
        'next-at-top', 'next-at-bottom', 'hide-next'
      );
      document.body.classList.add('align-' + alignmentClass);
      alignment = alignmentClass;

      if (alignmentClass === 'top') {
        document.body.classList.add('next-at-bottom');
      } else if (alignmentClass === 'bottom') {
        document.body.classList.add('next-at-top');
      } else if (alignmentClass === 'center') {
        document.body.classList.add('hide-next');
      }

      showSubtitle();
    }

    function loadSubtitlesFromText(text) {
      const rawBlocks = text.trim().split(/\n\s*\n/);
      subtitles = [];
      accessPoints = [];

      rawBlocks.forEach((block) => {
        const trimmedBlock = block.trim();
        if (trimmedBlock.startsWith('*')) {
          const label = trimmedBlock.replace(/^\*\s*/, '');
          accessPoints.push({ label, index: subtitles.length });
        } else {
          subtitles.push(trimmedBlock);
        }
      });

      currentIndex = 0;
      fileInputContainer.style.display = 'none';
      showSubtitle();
    }

    function showSubtitle() {
      if (subtitles.length === 0) {
        currentDiv.textContent = '';
        nextDiv.textContent = '';
        return;
      }

      const current = subtitles[currentIndex];
      let next = '';
      for (let i = currentIndex + 1; i < subtitles.length; i++) {
        if (!subtitles[i].startsWith('*')) {
          next = subtitles[i];
          break;
        }
      }

      currentDiv.textContent = current === '---' ? '' : current;
      nextDiv.textContent = (next === '---') ? '' : next;
    }

    function showAccessPointDialog() {
      if (accessPoints.length === 0) {
        alert("No hi ha cap punt d'accés.");
        return;
      }
      const menu = accessPoints.map((p, i) => `${i + 1}. ${p.label}`).join('\n');
      const input = prompt(`Tria un punt d'accés:\n${menu}`);
      const selectedIndex = parseInt(input) - 1;
      if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < accessPoints.length) {
        currentIndex = accessPoints[selectedIndex].index;
        showSubtitle();
      }
    }

    fileInput.addEventListener('change', function () {
      const file = fileInput.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          loadSubtitlesFromText(e.target.result);
        };
        reader.readAsText(file, 'utf-8');
      }
    });

    document.addEventListener('keydown', function(e) {
      switch (e.key) {
        case 'ArrowRight':
          if (currentIndex < subtitles.length - 1) currentIndex++;
          showSubtitle();
          break;
        case 'ArrowLeft':
          if (currentIndex > 0) currentIndex--;
          showSubtitle();
          break;
        case 'l':
          e.preventDefault();
          showAccessPointDialog();
          break;
        case 'q': updateAlignment('top'); break;
        case 'a': updateAlignment('center'); break;
        case 'z': updateAlignment('bottom'); break;
        case '-':
          if (fontSize > 1) fontSize -= fontStep;
          updateFontSize();
          break;
        case '+':
        case '=':
          if (e.shiftKey || e.key === '+') {
            fontSize += fontStep;
            updateFontSize();
          }
          break;
        case 'o':
        case 'O':
          e.preventDefault();
          nextDiv.style.display = nextDiv.style.display === 'none' ? 'block' : 'none';
          break;
        case 'f':
        case 'F':
          setNextGray(grayLevel + 1);
          break;
        case 'c':
        case 'C':
          setNextGray(grayLevel - 1);
          break;
      }
    });

    document.addEventListener('dblclick', showAccessPointDialog);

    // Gestos arrossegar per canviar mida
    let dragStartX = null;
    let dragStartY = null;
    document.addEventListener('mousedown', (e) => {
      dragStartX = e.clientX;
      dragStartY = e.clientY;
    });
    document.addEventListener('mouseup', (e) => {
      if (dragStartX !== null && dragStartY !== null) {
        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;
        handleFontResizeByDrag(deltaY);  // Ara és vertical per a mida
        dragStartX = null;
        dragStartY = null;
      }
    });

    let touchStartX = null;
    let touchStartY = null;
    document.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    });

    document.addEventListener('touchend', (e) => {
      if (touchStartX !== null && touchStartY !== null && e.changedTouches.length === 1) {
        const deltaX = e.changedTouches[0].clientX - touchStartX;
        const deltaY = e.changedTouches[0].clientY - touchStartY;

        // Només si el moviment és més horitzontal que vertical
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (Math.abs(deltaX) > 100) {
            // Gran moviment horitzontal → canvia mida
            handleFontResizeByDrag(deltaY); // Mida per arrossegar vertical
          } else if (deltaX > 30) {
            // Lliscar cap a la dreta → retrocedir
            if (currentIndex > 0) {
              currentIndex--;
              showSubtitle();
            }
          } else if (deltaX < -30) {
            // Lliscar cap a l'esquerra → avançar
            if (currentIndex < subtitles.length - 1) {
              currentIndex++;
              showSubtitle();
            }
          }
        }

        touchStartX = null;
        touchStartY = null;
      }
    });

    function handleFontResizeByDrag(deltaY) {
      if (deltaY > 50) {
        fontSize += fontStep;
        updateFontSize();
      } else if (deltaY < -50) {
        if (fontSize > 1) {
          fontSize -= fontStep;
          updateFontSize();
        }
      }
    }

    updateAlignment('top');
    setNextGray(grayLevel);
  </script>
</body>
</html>
